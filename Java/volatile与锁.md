| 对比点     | **volatile**                                                 | **synchronized**                                             |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 原子性     | 无法保证                                                     | 可以保证                                                     |
| 可见性     | 可以保证，相比锁更轻不用切换线程上下文<br />可见性问题是通过内存屏障禁止指令重排序实现的<br />内存屏障相关参考`《缓存一致性协议#内存屏障》` | 可以保证<br />同步块：编译器在入口和退出位置分别插入 monitorenter 和 monitorexit 字节码指令<br />同步方法：编译器在方法表中设置该方法的 synchronized=1，表示该方法是同步方法 |
| 线程阻塞   | 不会出现线程阻塞                                             | 获得锁的线程将阻塞其他线程                                   |
| 适用范围   | 仅能用在变量上                                               | 能修饰方法和代码块                                           |
| 编译器优化 | volatile 变量不会被编译器优化，可以禁止指令重排              | synchronized 变量可以被编译器优化（锁粗化、锁消除、锁升级）  |

~~锁消除~~synchronized修饰的代码中，如果不存在操作临界资源的情况就消除这个锁

~~锁膨胀~~如果在一个循环中频繁获取和释放锁，这样带来的消耗很大，锁膨胀就是将锁的范围扩大，避免上下文频繁切换

~~锁升级~~

锁升级就是 无锁 → 偏向锁 → 轻量级锁 → 重量级锁，尽量避免使用重量级锁带来的开销

> 无锁：第一次有线程访问锁，锁标志位01不变，偏向锁标志位变为1，线程指针指向当前线程（升级为偏向锁）
> 偏向锁：如果存在锁竞争，即访问锁和线程指针指向的线程不是同一个，锁标志位变为00（升级为轻量级锁）
> 轻量级锁：获得轻量级锁的方式是 CAS，如果自旋到了一定次数还拿不到锁，锁标志位变为10（升级为重量级锁）

<img src="C:\backup\assets\20231008105906.png" style="zoom:67%;" />

<img src="C:\backup\assets\20231008105918.png" style="zoom:43%;" />