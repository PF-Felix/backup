# ğŸ¥‡ConcurrentHashMap

å­˜å‚¨ç»“æ„ï¼šæ•°ç»„+é“¾è¡¨+çº¢é»‘æ ‘

é€šè¿‡ CAS å’Œ synchronized äº’æ–¥é”å®ç°çš„**çº¿ç¨‹å®‰å…¨**
CASï¼šåœ¨æ²¡æœ‰hashå†²çªæ—¶ï¼ˆNodeè¦æ”¾åœ¨æ•°ç»„ä¸Šæ—¶ï¼‰
synchronizedï¼šåœ¨å‡ºç°hashå†²çªæ—¶ï¼ˆNodeå­˜æ”¾çš„ä½ç½®å·²ç»æœ‰æ•°æ®äº†ï¼‰

## ğŸ¥ˆput

è¿”å›å€¼æ˜¯ put ä¹‹å‰ key çš„ value
put ä¼šè¦†ç›–åŸå€¼ï¼ŒputIfAbsent ä¸ä¼š

```java
public V put(K key, V value) {
    return putVal(key, value, false);
}

public V putIfAbsent(K key, V value) {
    return putVal(key, value, true);
}
```

### æ·»åŠ æ•°æ®åˆ°æ•°ç»„

```java
final V putVal(K key, V value, boolean onlyIfAbsent) {
    //ä¸å…è®¸keyæˆ–è€…valueå‡ºç°nullï¼ˆHashMap æ”¯æŒ null value ä¸ null keyï¼‰
    if (key == null || value == null) throw new NullPointerException();

    //(h ^ (h >>> 16)) & HASH_BITS; HashMapä¸­æ²¡æœ‰HASH_BITS
    //h ^ (h >>> 16) æ˜¯æ‰°åŠ¨è®¡ç®—ï¼Œç›®çš„æ˜¯å°½é‡ä½¿å…ƒç´ åˆ†å¸ƒå‡åŒ€å‡å°‘ hash ç¢°æ’ï¼Œä¸‹é¢ä¸¾ä¾‹è¯´æ˜
    //    å‡è®¾æ•°ç»„çš„åˆå§‹åŒ–å®¹é‡ä¸º16å³10000ï¼Œlength-1=15å³1111
    //    å‡è®¾å‡ ä¸ªå¯¹è±¡çš„ hashCode ä¸º 1100 10010ã€1110 10010ã€11101 10010ï¼Œä¸åšæ‰°åŠ¨è®¡ç®—å°†å‘ç”Ÿ hash ç¢°æ’ï¼ˆå–æ¨¡å€¼ç›¸ç­‰ï¼‰
    //HASH_BITS = â€­01111111111111111111111111111111â€¬
    //HASH_BITS è®© hash çš„æœ€é«˜ä½è‚¯å®šä¸º0ä»£è¡¨æ­£æ•°ï¼ˆå…¶ä»–ä½ä¸å˜ï¼‰ï¼Œå› ä¸º hash å€¼ä¸ºè´Ÿæ•°æ—¶æœ‰ç‰¹æ®Šçš„å«ä¹‰
    //static final int MOVED     = -1; //ä»£è¡¨å½“å‰ä½ç½®æ­£åœ¨æ‰©å®¹
    //static final int TREEBIN   = -2; //ä»£è¡¨å½“å‰ä½ç½®æ˜¯ä¸€æ£µçº¢é»‘æ ‘
    //static final int RESERVED  = -3; // hash for transient reservations
    int hash = spread(key.hashCode());

    int binCount = 0;
    for (Node<K,V>[] tab = table;;) {
        //nï¼šæ•°ç»„é•¿åº¦
        //iï¼šç´¢å¼•ä½ç½®
        //fï¼šiç´¢å¼•ä½ç½®çš„Nodeå¯¹è±¡
        //fhï¼šiç´¢å¼•ä½ç½®ä¸Šæ•°æ®çš„hashå€¼
        Node<K,V> f; int n, i, fh;

        //éœ€è¦çš„è¯å…ˆåˆå§‹åŒ–æ•°ç»„
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();

        //ï¼ˆå–æ¨¡è¿ç®—ï¼‰å®šä½å…ƒç´ åœ¨æ•°ç»„å“ªä¸ªç´¢å¼•ï¼šhash & (length -1)ï¼Œè¿ç®—ç»“æœæœ€å¤§å€¼ä¸º length -1ï¼Œä¸ä¼šå‡ºç°æ•°ç»„ä¸‹æ ‡è¶Šç•Œçš„æƒ…å†µ
        //å¦‚æœè¿™ä¸ªä½ç½®æ²¡æœ‰æ•°æ®ï¼Œå°±æŠŠæ•°æ®æ”¾åœ¨è¿™ä¸ªä½ç½®ï¼ˆCASï¼‰
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))
                break;
        }

        //å¦‚æœç´¢å¼•ä½ç½®æœ‰æ•°æ®ï¼Œä¸”æ­£åœ¨æ‰©å®¹ï¼Œå°±ååŠ©æ‰©å®¹
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);

        //ç´¢å¼•ä½ç½®æœ‰æ•°æ®ï¼Œä¸”æ²¡æœ‰åœ¨æ‰©å®¹ï¼ŒæŠŠå…ƒç´ æ’å…¥é“¾è¡¨æˆ–çº¢é»‘æ ‘ï¼ŒåŠ é”ï¼Œäº’æ–¥é”é”ä½ä¸€ä¸ªç´¢å¼•ï¼Œå…¶ä»–ç´¢å¼•å¯ä»¥æ­£å¸¸è®¿é—®
        //ç„¶åå¦‚æœé“¾è¡¨é•¿åº¦>=8ï¼Œè½¬åŒ–ä¸ºçº¢é»‘æ ‘æˆ–æ‰©å®¹
        else {
            V oldVal = null;
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    //ï¼ˆå…ƒç´ çš„hash>=0ï¼‰éå†é“¾è¡¨æ·»åŠ å…ƒç´ 
                    if (fh >= 0) {
                        binCount = 1; //...éå†æœŸé—´binCount++
                    }
                    
                    //å¦‚æœfh<0ï¼ˆå…ƒç´ çš„hash<0ï¼‰ï¼Œä¸”ç´¢å¼•ä½ç½®æ˜¯çº¢é»‘æ ‘ï¼Œå‘æ ‘ä¸­æ’å…¥å…ƒç´ 
                    else if (f instanceof TreeBin) {
                        Node<K,V> p;
                        binCount = 2;
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                //é“¾è¡¨é•¿åº¦>=8ï¼Œè½¬ä¸ºçº¢é»‘æ ‘æˆ–æ‰©å®¹
                //ä¸ºä½•æ˜¯8ï¼Ÿæ ¹æ®æ³Šæ¾åˆ†å¸ƒï¼Œé“¾è¡¨é•¿åº¦åˆ°8çš„æ¦‚ç‡éå¸¸ä½ï¼Œæºç ä¸­æ˜¯0.00...6ï¼Œå°½é‡åœ¨é¿å…ç”Ÿæˆçº¢é»‘æ ‘ä½¿å†™å…¥æˆæœ¬è¿‡é«˜
                //            æ•°ç»„é•¿åº¦<64ï¼Œæ‰©å®¹ï¼Œå®¹é‡ç¿»å€
                //            æ•°ç»„é•¿åº¦>=64ï¼Œè½¬ä¸ºçº¢é»‘æ ‘
                if (binCount >= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    
    //æ•°é‡+1 ä¸”åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹
    addCount(1L, binCount);
    return null;
}
```

### åˆå§‹åŒ–

```java
//sizeCtlï¼šæ˜¯æ•°ç»„åœ¨åˆå§‹åŒ–å’Œæ‰©å®¹æ“ä½œæ—¶çš„ä¸€ä¸ªæ§åˆ¶å˜é‡
//0ï¼šä»£è¡¨æ•°ç»„è¿˜æ²¡åˆå§‹åŒ–
//å¤§äº0ï¼šä»£è¡¨å½“å‰æ•°ç»„çš„æ‰©å®¹é˜ˆå€¼ï¼Œæˆ–è€…æ˜¯å½“å‰æ•°ç»„çš„åˆå§‹åŒ–å¤§å°
//-1ï¼šä»£è¡¨å½“å‰æ•°ç»„æ­£åœ¨åˆå§‹åŒ–
//å°äº-1ï¼šä½16ä½ä»£è¡¨å½“å‰æ•°ç»„æ­£åœ¨æ‰©å®¹çš„çº¿ç¨‹ä¸ªæ•°ï¼ˆå¦‚æœ1ä¸ªçº¿ç¨‹æ‰©å®¹ï¼Œå€¼ä¸º-2ï¼Œå¦‚æœ2ä¸ªçº¿ç¨‹æ‰©å®¹ï¼Œå€¼ä¸º-3ï¼‰
private final Node<K,V>[] initTable() {
    Node<K,V>[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        if ((sc = sizeCtl) < 0)
            Thread.yield();

        //CASå°†SIZECTLæ”¹ä¸º-1ï¼Œå°è¯•åˆå§‹åŒ–
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    //å¦‚æœsizeCtl > 0 å°±åˆå§‹åŒ–sizeCtlé•¿åº¦çš„æ•°ç»„ï¼›å¦‚æœsizeCtl == 0ï¼Œå°±åˆå§‹åŒ–é»˜è®¤çš„é•¿åº¦16
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                    table = tab = nt;
                    //å°†scèµ‹å€¼ä¸ºä¸‹æ¬¡æ‰©å®¹çš„é˜ˆå€¼
                    sc = n - (n >>> 2);
                }
            } finally {
                //sizeCtlä¸ºä¸‹æ¬¡æ‰©å®¹çš„é˜ˆå€¼
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
```

### treeifyBin

```java
private final void treeifyBin(Node<K,V>[] tab, int index) {
    Node<K,V> b; int n, sc;
    if (tab != null) {
        if ((n = tab.length) < MIN_TREEIFY_CAPACITY)
            tryPresize(n << 1);

        //è½¬çº¢é»‘æ ‘éœ€è¦åŠ é”
        else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {
            synchronized (b) {
                //çœç•¥ä¸€å¤§æ®µä»£ç 
            }
        }
    }
}

private final void tryPresize(int size) {
    int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :
    tableSizeFor(size + (size >>> 1) + 1);
    int sc;

    //æ•°ç»„æ²¡æœ‰åœ¨åˆå§‹åŒ–ï¼Œä¹Ÿæ²¡æœ‰åœ¨æ‰©å®¹
    while ((sc = sizeCtl) >= 0) {
        Node<K,V>[] tab = table; int n;

        //åˆå§‹åŒ–ï¼ŒåŒä¸Š
        if (tab == null || (n = tab.length) == 0) {
            //çœç•¥
        }

        //å®¹é‡å·²ç»åˆ°äº†æœ€å¤§ï¼Œå°±ä¸æ‰©å®¹äº†
        else if (c <= sc || n >= MAXIMUM_CAPACITY)
            break;

        //æ‰©å®¹ï¼Œå¸®åŠ©å…¶ä»–çº¿ç¨‹æ‰©å®¹ æˆ– è‡ªå·±æ‰©å®¹
        else if (tab == table) {
            int rs = resizeStamp(n);
            if (sc < 0) {
                Node<K,V>[] nt;
                //åˆ¤æ–­æ˜¯å¦å¯ä»¥ååŠ©æ‰©å®¹
                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex <= 0)
                    break;
                //sizeCtl+1ï¼Œè¡¨ç¤ºæ‰©å®¹çš„çº¿ç¨‹æ•°é‡+1ï¼Œå¹¶ååŠ©æ‰©å®¹
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            }

            //è‡ªå·±æ‰©å®¹ï¼ŒsizeCtl+2ï¼Œè¡¨ç¤ºå½“å‰æœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨æ‰©å®¹
            else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs << RESIZE_STAMP_SHIFT) + 2))
                transfer(tab, null);
        }
    }
}
```

### addCount

```java
private final void addCount(long x, int check) {
    CounterCell[] as; long b, s;
    //ä¸é‡è¦
    if ((as = counterCells) != null ||
        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
        //çœç•¥ä¸€å¤§æ®µä»£ç 
    }

    if (check >= 0) {
        Node<K,V>[] tab, nt; int n, sc;
        //å½“å‰å…ƒç´ ä¸ªæ•°å¤§äºç­‰äºæ‰©å®¹é˜ˆå€¼ï¼Œä¸”æ•°ç»„ä¸ä¸ºnullï¼Œä¸”æ•°ç»„é•¿åº¦æ²¡æœ‰è¾¾åˆ°æœ€å¤§å€¼ï¼ŒååŠ©å…¶ä»–çº¿ç¨‹æ‰©å®¹æˆ–è‡ªå·±æ‰©å®¹
        while (s >= (long)(sc = sizeCtl) && (tab = table) != null && (n = tab.length) < MAXIMUM_CAPACITY) {
            int rs = resizeStamp(n);
            //çœç•¥ä¸€æ®µå’Œ tryPresize ä¸€æ ·çš„ä»£ç 
            s = sumCount();
        }
    }
}
```

### æ‰©å®¹

æ”¯æŒå¤šçº¿ç¨‹å¹¶å‘æ‰©å®¹

è§¦å‘æ‰©å®¹çš„ä¸‰ä¸ªç‚¹ï¼š

- é“¾è¡¨è½¬çº¢é»‘æ ‘å‰ï¼Œä¼šåˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹
- addCount æ–¹æ³•ä¸­ï¼Œå¦‚æœå…ƒç´ æ•°é‡è¶…è¿‡é˜ˆå€¼ï¼Œè§¦å‘æ‰©å®¹
- putAll æ–¹æ³•ä¸­ï¼Œæ ¹æ®ä¼ å…¥çš„ map.size åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹

```java
//tabï¼šè€æ•°ç»„
//nextTabï¼šæ–°æ•°ç»„
private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {
    int n = tab.length, stride;

    //åŸºäºCPUå†…æ ¸æ•°è®¡ç®—æ¯ä¸ªçº¿ç¨‹ä¸€æ¬¡æ€§è¿ç§»å¤šå°‘æ•°æ®
    //æ¯ä¸ªçº¿ç¨‹è¿ç§»æ•°ç»„é•¿åº¦æœ€å°å€¼æ˜¯MIN_TRANSFER_STRIDE=16
    if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE;

    //æ²¡æœ‰æ–°æ•°ç»„çš„è¯ï¼Œåˆ›å»ºä¸€ä¸ªå®¹é‡ç¿»å€çš„æ–°æ•°ç»„
    if (nextTab == null) {
        try {
            Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];
            nextTab = nt;
        } catch (Throwable ex) {
            sizeCtl = Integer.MAX_VALUE;
            return;
        }
        nextTable = nextTab;

        //æ‰©å®¹æ€»è¿›åº¦ï¼Œ>=transferIndexçš„ç´¢å¼•éƒ½å·²åˆ†é…å‡ºå»
        transferIndex = n;
    }
    int nextn = nextTab.length;
    ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab); //MOVEDèŠ‚ç‚¹
    boolean advance = true;
    boolean finishing = false; // to ensure sweep before committing nextTab
    for (int i = 0, bound = 0;;) {
        Node<K,V> f; int fh;
        while (advance) {
            int nextIndex, nextBound;

            //ç¬¬ä¸€æ¬¡å¾ªç¯ä¸ä¼šè¿›æ¥
            //ä¹‹åé¢†å–äº†ä»»åŠ¡ä¹‹åå°±å¯ä»¥è¿›æ¥äº†ï¼ŒæŒ‰ç´¢å¼•é¡ºåºä»åå¾€å‰ä¸€ä¸ªä¸ªå¤„ç†
            if (--i >= bound || finishing)
                advance = false;

            //transferIndex <=0 è¡¨ç¤ºæ‰€æœ‰ç´¢å¼•éƒ½è¿ç§»å®Œæˆ
            else if ((nextIndex = transferIndex) <= 0) {
                i = -1;
                advance = false;
            }

            //å½“å‰çº¿ç¨‹å°è¯•é¢†å–ä»»åŠ¡ï¼Œé¢†å–ä¸€æ®µæ•°ç»„çš„æ•°æ®è¿ç§»
            else if (U.compareAndSwapInt(this, TRANSFERINDEX, nextIndex,
                      nextBound = (nextIndex > stride ? nextIndex - stride : 0))) {
                bound = nextBound;
                //æ ‡è®°ç´¢å¼•ä½ç½®
                i = nextIndex - 1;
                advance = false;
            }
        }

        //i < 0ï¼Œå³çº¿ç¨‹æ²¡æœ‰æ¥æ”¶åˆ°ä»»åŠ¡ï¼Œæ‰©å®¹çº¿ç¨‹æ•°é‡-1ï¼Œç»“æŸæ‰©å®¹æ“ä½œ
        if (i < 0 || i >= n || i + n >= nextn) {
            int sc;
            if (finishing) {
                nextTable = null;
                table = nextTab;
                sizeCtl = (n << 1) - (n >>> 1);
                return;
            }
            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
                if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)
                    return;
                finishing = advance = true;
                i = n; // recheck before commit
            }
        }

        //å¦‚æœå½“å‰ç´¢å¼•ä½ç½®æ²¡æ•°æ®ï¼Œæ— éœ€è¿ç§»ï¼Œæ ‡è®°ä¸ºMOVED
        else if ((f = tabAt(tab, i)) == null)
            advance = casTabAt(tab, i, null, fwd);

        //å¦‚æœå½“å‰ç´¢å¼•ä½ç½®çš„ hash æ˜¯ MOVEDï¼Œè¡¨ç¤ºå·²ç»è¿ç§»è¿‡äº†
        else if ((fh = f.hash) == MOVED)
            advance = true;

        //è¿ç§»æ•°æ®ï¼Œå°† oldTable çš„æ•°æ®è¿ç§»åˆ° newTableï¼ŒåŠ é”
        else {
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    Node<K,V> ln, hn;

                    //æ­£å¸¸æƒ…å†µï¼Œé“¾è¡¨
                    if (fh >= 0) {
                        //è¿ç®—ç»“æœæ˜¯0æˆ–nï¼šæ¯”å¦‚16ï¼ˆå³10000ï¼‰&ä»»ä½•hash åªæœ‰10000ï¼ˆhash=X1XXXXï¼‰å’Œ0ï¼ˆhash=X0XXXXï¼‰ä¸¤ç§ç»“æœ
                        //hash&15ï¼ˆå³01111ï¼‰çš„ç»“æœæ˜¯A
                        //hash&31ï¼ˆå³11111ï¼‰çš„ç»“æœæ˜¯B
                        //Aå’ŒBåªæœ‰ä¸¤ç§æƒ…å†µï¼šA==Bï¼ˆhash=X0XXXXï¼‰ æˆ–è€… A+16==Bï¼ˆhash=X1XXXXï¼‰
                        //å› æ­¤æ‰©å®¹åç´¢å¼•ä½ç½®ä¸å˜ æˆ– ç´¢å¼•ä½ç½®+n
                        int runBit = fh & n;
                        Node<K,V> lastRun = f;

                        //æ‰¾å‡ºæœ€åä¸€æ®µ hash&n è¿ç»­ä¸å˜çš„é“¾è¡¨
                        //    å³ä» lastRun å¼€å§‹åé¢çš„è¿™ä¸€æ®µæ•°æ®å°±ä¸ç”¨é‡æ–°åˆ›å»ºèŠ‚ç‚¹äº†ï¼Œå‰é¢çš„æ•°æ®è¿˜éœ€è¦åˆ›å»ºèŠ‚ç‚¹
                        //runBit == 0 è¡¨ç¤ºæ‰©å®¹å‰åç´¢å¼•ä½ç½®ä¸å˜ï¼Œå…¶ä»–æƒ…å†µè¡¨ç¤ºç´¢å¼•ä½ç½®éœ€è¦å˜åŠ¨
                        for (Node<K,V> p = f.next; p != null; p = p.next) {
                            //è¿™é‡Œä¹Ÿæ˜¯0æˆ–n
                            int b = p.hash & n;
                            if (b != runBit) {
                                runBit = b;
                                lastRun = p;
                            }
                        }
                        if (runBit == 0) {
                            ln = lastRun;
                            hn = null;
                        }
                        else {
                            hn = lastRun;
                            ln = null;
                        }

                        //lastRun ä¹‹å‰çš„ç»“ç‚¹é‡æ–°åˆ›å»ºèŠ‚ç‚¹
                        for (Node<K,V> p = f; p != lastRun; p = p.next) {
                            int ph = p.hash; K pk = p.key; V pv = p.val;
                            if ((ph & n) == 0)
                                ln = new Node<K,V>(ph, pk, pv, ln);
                            else
                                hn = new Node<K,V>(ph, pk, pv, hn);
                        }
                        //ä½ä½é“¾è¡¨
                        setTabAt(nextTab, i, ln);
                        //é«˜ä½é“¾è¡¨
                        setTabAt(nextTab, i + n, hn);
                        //è®¾ç½®å½“å‰ç´¢å¼•ä¸ºMOVED
                        setTabAt(tab, i, fwd);
                        advance = true;
                    }

                    //çº¢é»‘æ ‘
                    else if (f instanceof TreeBin) {
                        //å¿½ç•¥ä¸€å¤§æ®µä»£ç 
                    }
                }
            }
        }
    }
}
```

## ğŸ¥ˆHashMapçº¿ç¨‹ä¸å®‰å…¨çš„åŸå› 

- åœ¨ Java7 ä¸­ï¼Œå¹¶å‘æ‰§è¡Œæ‰©å®¹æ“ä½œæ—¶ä¼šé€ æˆç¯å½¢é“¾è¡¨å’Œæ•°æ®ä¸¢å¤±çš„æƒ…å†µ
- åœ¨ Java8 ä¸­ï¼Œå¹¶å‘æ‰§è¡Œputæ“ä½œæ—¶ä¼šå‘ç”Ÿæ•°æ®è¦†ç›–çš„æƒ…å†µ

## ğŸ¥ˆHashMap VS HashTable VS ConcurrentHashMap

|                  | HashMap    | HashTable                                        | ConcurrentHashMap |
| ---------------- | ---------- | ------------------------------------------------ | ----------------- |
| çº¿ç¨‹å®‰å…¨æ€§       | éçº¿ç¨‹å®‰å…¨ | çº¿ç¨‹å®‰å…¨                                         | çº¿ç¨‹å®‰å…¨          |
| æ˜¯å¦å…è®¸KVä¸ºnull | å…è®¸       | ä¸å…è®¸                                           | ä¸å…è®¸            |
| å…¶ä»–             |            | HashTableé”ç²’åº¦å¤ªç²—ï¼Œæ²¡æœ‰ConcurrentHashMapæ€§èƒ½å¥½ | å»ºè®®æ›¿ä»£HashTable |

## ğŸ¥ˆHashMap VS ConcurrentHashMap

å­˜å‚¨ç»“æ„ä¸€æ ·ï¼Œéƒ½æ˜¯æ•°ç»„+é“¾è¡¨+çº¢é»‘æ ‘

é“¾è¡¨è½¬æ¢ä¸ºçº¢é»‘æ ‘çš„æ—¶æœºä¸€æ ·ï¼Œéƒ½æ˜¯é“¾è¡¨é•¿åº¦>=8
çº¢é»‘æ ‘è½¬æ¢ä¸ºé“¾è¡¨çš„æ—¶æœºä¸€æ ·ï¼Œéƒ½æ˜¯æ ‘ä¸ŠèŠ‚ç‚¹æ•°é‡<=6

æ‰©å®¹éƒ½æ˜¯å˜ä¸ºåŸæ¥çš„ä¸¤å€

æ‰©å®¹æ—¶æœºä¸ä¸€æ ·ï¼š

- ConcurrentHashMapï¼šé“¾è¡¨é•¿åº¦>=8ä¸”æ•°ç»„é•¿åº¦<64 æˆ– å½“å‰å…ƒç´ ä¸ªæ•°å¤§äºç­‰äºæ‰©å®¹é˜ˆå€¼å³æ•°ç»„é•¿åº¦ï¼ˆæ»¡äº†å†æ‰©å®¹ï¼‰
- HashMapï¼šå…ƒç´ ä¸ªæ•°è¶…è¿‡è´Ÿè½½å› å­ä¸å®¹é‡çš„ä¹˜ç§¯ï¼Œè´Ÿè½½å› å­ç”¨æ¥è¡¡é‡ä½•æ—¶è‡ªåŠ¨æ‰©å®¹
  ä¾‹å¦‚è´Ÿè½½å› å­é»˜è®¤ä¸º 0.75ï¼ˆæ„å‘³ç€å…ƒç´ æ•°é‡è¾¾åˆ°å½“å‰å®¹é‡çš„çš„ 3/4 æ—¶æ‰©å®¹ï¼‰

## ğŸ¥ˆTreeMap

æ”¯æŒæ ¹æ® key è‡ªå®šä¹‰æ’åºï¼ˆé»˜è®¤å‡åºï¼‰ï¼Œkey å¿…é¡»å®ç° Comparable æ¥å£æˆ–è€…åœ¨æ„é€ æ–¹æ³•ä¼ å…¥è‡ªå®šä¹‰çš„ Comparator

# ğŸ¥‡CopyOnWriteArrayList

æ˜¯çº¿ç¨‹å®‰å…¨çš„ ArrayList

å†™æ•°æ®æ—¶åŠ é”ï¼ŒåŒæ—¶å¤åˆ¶ä¸€ä¸ªæ•°ç»„çš„å‰¯æœ¬ï¼Œå†™è¿™ä¸ªå‰¯æœ¬ï¼Œå®Œæˆå†™ä¹‹åå†ç”¨å‰¯æœ¬æ›¿æ¢æ‰åŸæ•°ç»„ï¼›å†™æ“ä½œä¸å½±å“è¯»æ“ä½œ

åˆå§‹é•¿åº¦æ˜¯0

ä½¿ç”¨è¿­ä»£å™¨åšå†™æ“ä½œä¼šæŠ›å¼‚å¸¸