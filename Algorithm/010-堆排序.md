# 完全二叉树

完全二叉树，除了最后一层外，其他所有层的节点都是满的，并且最后一层的节点都靠左排列。

满二叉树和空树 也是完全二叉树。

# 堆

堆是完全二叉树。

堆的每个节点都`≥其两个孩子`（大根堆）或者`≤其两个孩子`（小根堆）。

**堆用数组表示**

任何位置 i 的元素

- 左孩子的位置 = 2i + 1
- 右孩子的位置 = 2i + 2
- 父节点的位置 (i-1)/2

堆可以使用数组来表示，其中数组下标从0开始，节点的索引和它在数组中的位置有关。根据完全二叉树的性质，节点i的左子节点在位置2i+1

# 建立大根堆

有两种方式：

| **方式一**                                                   | **方式二**                                                   |      |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| 认为数组元素是一个个塞进来的，正序遍历数组一个个处理         | 从尾部节点倒序遍历数组调整                                   |      |
| 每个节点的处理逻辑就是，递归和父节点比较，如果我比父节点大就和父节点交换，直到我不比父节点大停止 | 每个节点的处理逻辑是，递归比较，如果此节点有孩子且有孩子比它大，就交换，直到无孩子或找不到比它大的孩子 |      |
| <img src="C:\ImageA\image-20231119111652915.png" alt="image-20231119111652915" style="zoom:40%;" /> | <img src="C:\ImageA\image-20231119112122007.png" alt="image-20231119112122007" style="zoom:30%;" /> |      |
| ~~时间复杂度~~<br />循环次数是 n 次：O(n)<br />循环体方法的比较次数最多就是树高，即 logn：O(logn)<br />因此时间复杂度是 O(n*logn) | ~~时间复杂度~~是 O(n)<br />n/2：叶子节点的数量，循环判断的次数是 1 次<br />n/4：倒数第二层节点数量，循环判断的次数是 2 次<br />n/8：倒数第三层节点数量，循环判断的次数是 3 次<br />n/16：倒数第三层节点数量，循环判断的次数是 4 次<br />时间复杂度的计算参考下面的公式 |      |



$$
T = \frac{n}{2} * 1 + \frac{n}{4} * 2 + \frac{n}{8} * 3 + \frac{n}{16} * 4 + \frac{n}{32} * 5 ...
$$

$$
2T = n + \frac{n}{2} * 2 + \frac{n}{4} * 3 + \frac{n}{8} * 4 + \frac{n}{16} * 5 ...
$$

$$
T = 2T - T = n + \frac{n}{2} + \frac{n}{4} + \frac{n}{8} + \frac{n}{16} ...
$$

# 堆排序

下图是大根堆排序算法。简述步骤就是

1. 创建大根堆
2. 将堆顶（最大元素）和尾部元素交换
3. 重新调整堆为大根堆
4. 重复上述步骤2和步骤3

<img src="C:\ImageA\image-20231119124332549.png" alt="image-20231119124332549" style="zoom: 33%;" />

**算法**

<img src="C:\ImageA\image-20231119125340628.png" alt="image-20231119125340628" style="zoom:40%;" />

**时间复杂度**

<img src="C:\ImageA\image-20231119140210270.png" alt="image-20231119140210270" style="zoom:40%;" />

# 最大线段重合问题

<img src="C:\ImageA\image-20231130191533803.png" alt="image-20231130191533803" style="zoom:50%;" />

<img src="C:\ImageA\image-20231130190400559.png" alt="image-20231130190400559" style="zoom:25%;" />

1. 线段按左端点从小到大排序
2. 遍历扫描所有线段
   1. 如果堆是空的，线段直接入堆（小顶堆），入堆的是线段的右端点
   2. 如果堆不空，查看当前线段是否与堆中所有线段相交（有一个不相交都不行）
      1. 如果当前线段左端点大于堆中右端点最小值或者重合，说明当前线段不是和所有线段相交。此时堆顶（最小值）弹出，重复次步骤的比较
      2. 反之则说明都重合，入堆

核心代码如下：

<img src="C:\ImageA\image-20231130193430583.png" alt="image-20231130193430583" style="zoom:50%;" />

# 其他

java 中的 PriorityQueue 是小根堆

堆结构常用于 TopK 问题
