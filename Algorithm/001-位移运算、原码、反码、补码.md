代码见`Day001_位移运算_原码反码补码.java`

# 左移和右移

- 无符号左移：Java没有无符号左移
- 无符号右移：左边补0
- 有符号右移：左边用原符号位补位 即正数补0效果同无符号右移、负数补1
- 有符号左移：右边补0

代码举例如下：

```java
private void test01(boolean print) {
    int num_5 = 5;
    int num_5_2 = -5;
    System.out.println("无符号右移：正数");
    for (int i = 0; i < 5; i++) {
        print(num_5 >>> i, print);
    }
    System.out.println("无符号右移：负数");
    for (int i = 0; i < 5; i++) {
        print(num_5_2 >>> i, print);
    }
    System.out.println("有符号右移：正数");
    for (int i = 0; i < 5; i++) {
        print(num_5 >> i, print);
    }
    System.out.println("有符号右移：负数");
    for (int i = 0; i < 5; i++) {
        print(num_5_2 >> i, print);
    }
    System.out.println("有符号左移：正数");
    for (int i = 0; i < 32; i++) {
        print(num_5 << i, print);
    }
    System.out.println("有符号左移：负数");
    for (int i = 0; i < 32; i++) {
        print(num_5_2 << i, print);
    }
}
private void print(int x, boolean print) {
    if (print) {
        print(x);
    } else {
        System.out.println(Integer.toBinaryString(x));
    }
}
/**
  * 输出十进制数的二进制格式
  */
private void print(int num) {
    for (int i = 31; i >= 0; i--) {
        System.out.print((num & (1 << i)) == 0 ? "0" : "1");
    }
    System.out.println();
}
```

输出：

```
无符号右移：正数
00000000000000000000000000000101
00000000000000000000000000000010
00000000000000000000000000000001
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000101
无符号右移：负数
11111111111111111111111111111011
01111111111111111111111111111101
00111111111111111111111111111110
00011111111111111111111111111111
00001111111111111111111111111111
00000111111111111111111111111111
00000011111111111111111111111111
00000001111111111111111111111111
00000000111111111111111111111111
00000000011111111111111111111111
00000000001111111111111111111111
00000000000111111111111111111111
00000000000011111111111111111111
00000000000001111111111111111111
00000000000000111111111111111111
00000000000000011111111111111111
00000000000000001111111111111111
00000000000000000111111111111111
00000000000000000011111111111111
00000000000000000001111111111111
00000000000000000000111111111111
00000000000000000000011111111111
00000000000000000000001111111111
00000000000000000000000111111111
00000000000000000000000011111111
00000000000000000000000001111111
00000000000000000000000000111111
00000000000000000000000000011111
00000000000000000000000000001111
00000000000000000000000000000111
00000000000000000000000000000011
00000000000000000000000000000001
11111111111111111111111111111011
有符号右移：正数
00000000000000000000000000000101
00000000000000000000000000000010
00000000000000000000000000000001
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000101
有符号右移：负数
11111111111111111111111111111011
11111111111111111111111111111101
11111111111111111111111111111110
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111011
有符号左移：正数
00000000000000000000000000000101
00000000000000000000000000001010
00000000000000000000000000010100
00000000000000000000000000101000
00000000000000000000000001010000
00000000000000000000000010100000
00000000000000000000000101000000
00000000000000000000001010000000
00000000000000000000010100000000
00000000000000000000101000000000
00000000000000000001010000000000
00000000000000000010100000000000
00000000000000000101000000000000
00000000000000001010000000000000
00000000000000010100000000000000
00000000000000101000000000000000
00000000000001010000000000000000
00000000000010100000000000000000
00000000000101000000000000000000
00000000001010000000000000000000
00000000010100000000000000000000
00000000101000000000000000000000
00000001010000000000000000000000
00000010100000000000000000000000
00000101000000000000000000000000
00001010000000000000000000000000
00010100000000000000000000000000
00101000000000000000000000000000
01010000000000000000000000000000
10100000000000000000000000000000
01000000000000000000000000000000
10000000000000000000000000000000
00000000000000000000000000000101
有符号左移：负数
11111111111111111111111111111011
11111111111111111111111111110110
11111111111111111111111111101100
11111111111111111111111111011000
11111111111111111111111110110000
11111111111111111111111101100000
11111111111111111111111011000000
11111111111111111111110110000000
11111111111111111111101100000000
11111111111111111111011000000000
11111111111111111110110000000000
11111111111111111101100000000000
11111111111111111011000000000000
11111111111111110110000000000000
11111111111111101100000000000000
11111111111111011000000000000000
11111111111110110000000000000000
11111111111101100000000000000000
11111111111011000000000000000000
11111111110110000000000000000000
11111111101100000000000000000000
11111111011000000000000000000000
11111110110000000000000000000000
11111101100000000000000000000000
11111011000000000000000000000000
11110110000000000000000000000000
11101100000000000000000000000000
11011000000000000000000000000000
10110000000000000000000000000000
01100000000000000000000000000000
11000000000000000000000000000000
10000000000000000000000000000000
11111111111111111111111111111011
```

此外根据上面的测试结果，还可以得到下面的结论：
- int 类型位移 32/64位 还是它本身
- long 类型位移 64位 还是它本身

# 原码、反码、补码

执行了上面的代码可能会有疑问：
- 整型 5 的二进制是`00000000 00000000 00000000 00000101`
- 整型-5 的二进制是`10000000 00000000 00000000 00000101`
- 为什么测试代码的输出中 -5 的二进制输出是`11111111 11111111 11111111 11111011`？

**答案：这里输出的都是补码，计算机也是使用补码进行计算的。**

为什么用补码？下面讲解

首先，计算机中只计算加法：

- 减法可以转化为加法
- 乘法可以转化为加法和位移算法
- 除法可以转化为乘法，进而再转化为加法

**只计算加法能够简化电路的设计**  *存在的问题如下面举例*

数学计算`1-1=0`，如果让计算机计算就错了`1-1 = 1+(-1) = 0000 0001 + 1000 0001 = 1000 0010 = 十进制-2`

**因此就有了反码的诞生，而数字本身我们叫它原码**

反码计算规则：
- 正数的反码是它本身
- 负数的反码是：符号位不变，其他位取反

0的两种情况：全1零和全0零
- 全1零：`5-5=0`化为二进制运算就是`00000000 00000101 + 11111111 11111010 = 11111111 11111111`
- 全0零：`0+0=0`化为二进制运算就是`00000000 00000000 + 00000000 00000000 = 00000000 00000000`

**还有比反码更好的方案吗？有，那就是补码**

补码计算规则：
- 正数的补码是本身
- 负数的补码是反码+1

**相比反码，补码对于 0 的表示只有全0零，相比反码又简化了电路的设计**

相关测试代码片如下：

```java
public void test02() {
    int num = 5;
    System.out.println("正数5的补码是原码本身");
    print(num);
    System.out.println("正数5取反就是其相反数-5的反码");
    print(~num);
    System.out.println("-5用补码表示，是反码+1");
    print(-num);
}
```

输出：

```
正数5的补码是原码本身
00000000000000000000000000000101
正数5取反就是其相反数-5的反码
11111111111111111111111111111010
-5用补码表示，是反码+1
11111111111111111111111111111011
```

# 扩展：整型的最大值和最小值

```java
@Test
public void test03() {
    System.out.println("整型最大值是正 2的31次方-1 补码就是其本身");
    print(Integer.MAX_VALUE);
    System.out.println();
    System.out.println("整型最小值的补码");
    print(Integer.MIN_VALUE);
    System.out.println("补码取反");
    print(~Integer.MIN_VALUE);
    System.out.println("补码取反+1 就是整型最小值的相反数 即2的31次方 因此整型最小值是负 2的31次方");
}
```

输出：

```
整型最大值是正 2的31次方-1 补码就是其本身
01111111111111111111111111111111

整型最小值的补码
10000000000000000000000000000000
补码取反
01111111111111111111111111111111
补码取反+1 就是整型最小值的相反数 即2的31次方 因此整型最小值是负 2的31次方
```