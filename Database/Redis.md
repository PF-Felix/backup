# **

# 与memcached的区别

1、memcached 不具备持久化能力，redis 具备
2、redis 支持丰富的数据类型，memcached 只支持字符串
3、redis 支持在数据上计算
4、redis 还有其他 memcached 不具备的特性：Lua脚本、发布订阅、主从高可用
5、网络IO模型：redis是单线程的，memcached是多线程的
6、redis 原生支持分片集群，memcached 不支持

# 为什么要使用Redis

参考下一个问题：Redis合适的应用场景

# Redis合适的应用场景

考察对各种数据结构的理解，去上文的数据类型中找答案

# 为什么使用Pipeline

Redis 客户端执行一条命令分为如下4个部分：

1. 发送命令
2. 命令排队
3. 命令执行
4. 返回结果

其中1和4花费的时间称为 Round Trip Time（往返时间 RTT），即数据在网络上传输的时间

Redis 命令真正执行的时间通常在微秒级别，RTT 很可能要比这个时间大很多倍（根据光纤速度计算）

Pipeline 机制能改善上面这类问题，它能将一组命令进行组装，仅仅通过**一次RTT**传输给 Redis，再将这组命令的执行结果按顺序返回给客户端
不使用 Pipeline 的话整个过程需要**n次RTT**

我测试过10000次字符串数据类型的 set 写入，使用 pipeline 耗时10毫秒，不使用的话耗时1000毫秒，差距100倍

PS：Pipeline 虽然好用，但每次组装的命令个数也不能没有节制，因为数据量过大的话可能会长时间阻塞 Redis 的主线程，可以将一次包含大量命令的 Pipeline 拆分成多次较小的 Pipeline 来完成

# 为什么Redis单线程也这么快

**C语言实现，效率高**C语言程序运行时要比其他语言编写的程序快得多，因为它离底层机器很近

**纯内存访问**访问内存速度要比访问磁盘快得多

**单线程的优势**单线程能够避免上下文切换

**Pipeline**参考上面的问题：为什么使用Pipeline

**渐进式rehash**hash冲突过多的情况下，扩容采用渐进式rehash TODO

**基于epoll的多路复用NIO**
一般的IO操作是阻塞的，如果命令没有返回长时间阻塞就无法执行其他命令
epoll NIO 解决了IO操作阻塞的问题，如果命令没有返回可以继续执行其他命令

**lazyfree**参考上文的 lazyfree

# Redis真的是单线程吗

命令的执行和返回结果是由主线程串行执行的，但严格来说 Redis 并不是单线程

Redis 还有一些后台线程执行操作，例如清理脏数据、无用连接的释放、持久化

# Redis6.0之前为什么不使用多线程

官方曾做过类似问题的回复：Redis 几乎不存在 CPU 成为瓶颈的情况，主要受限于内存和网络
对于绝大多数企业来说，单线程性能足够了，因此没有必要使用多线程

# Redis6.0为什么要引入多线程

对于绝大多数企业来说，单线程性能足够了（8-10W的QPS），但是巨头公司需要更大的 QPS

使用多线程可以分摊 Redis 同步 IO 读写负荷

Redis 作者在一个分享中曾提到：Redis6 引入的多线程 IO 特性对性能提升至少是一倍以上
国内也有人进行过测试，GET/SET 命令在4线程 IO 时性能相比单线程是几乎翻倍
如果开启多线程，至少要4核的机器

# 什么情况下可能导致Redis阻塞

1、参考上文的 lazyfree
2、`keys *`数据量大的话阻塞
3、AOF同步写
4、持久化fork子进程（fork会复制父进程的空间内存页表，耗时跟内存量成正比，建议内存控制在10GB以内）