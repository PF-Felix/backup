# JVM内存模型

## 运行时数据区

![image-20230405163928650](D:\temporary\image-20230405163928650.png)

==方法区==

> 所有线程共享，在虚拟机启动时创建
> 用于存储虚拟机已经加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
> 当方法区无法满足内存分配需求时，抛出 OutOfMemoryError 异常

**永久代和元空间**

> 是 hotspot 虚拟机不同版本对方法区的实现（方法区是规范）
> java1.7及之前，有永久代
> java1.7之后，元空间替代了永久代，元空间不在虚拟机中，而是使用本地内存

**为什么使用元空间**

> 减少内存溢出，永久代的最大容量受制于 PermSize 和 MaxPermSize 参数设置的大小，这个大小很难确定，而元空间使用的是本地内存，大大减少内存溢出的可能性
> MaxMetaspaceSize 用于限制元数据的大小，如果没有指定这个参数，元空间将根据需要动态调整

==堆==

> 所有线程共享，在虚拟机启动时创建
> 存储对象实例和数组
> PS：对象也有可能《栈上分配》
> PS：对象也有可能不是共享的《TLAB》
> 当堆无法满足内存分配需求时，抛出 OutOfMemoryError 异常

==虚拟机栈==

> 线程私有，生命周期同线程
> 每个被线程执行的方法，都是虚拟机栈中的一个栈帧，一个方法对应一个栈帧，一个方法的调用就是一个栈帧的入栈和出栈过程，每个栈帧中包含局部变量表、操作数栈、指向运行时常量池的引用、返回地址、附加信息


> 局部变量表：存储方法中定义的局部变量以及方法的参数
> 局部变量表中的变量不可直接使用，必须通过相关指令将其加载至操作数栈中作为操作数使用
> 局部变量表在编译期就已经确定了大小，不能动态改变
> 操作数栈：以压栈和出栈的方式存储操作数
> 动态链接：支持方法的动态调用过程，被调用的方法在编译期无法被确定下来，只能在程序执行期间其符号引用转换为直接引用

==程序计数器==

> 线程私有
> 如果一个线程正在执行 java 方法，程序计数器存储的是正在执行的虚拟机字节码指令的地址
> 如果一个线程正在执行 native 方法，这个计数器为空

==本地方法栈==

> 线程私有
> 服务于本地方法

## 堆内存分代模型

> 一块是非堆区，一块是堆区
> 堆区分为两大区，Old+Young
> Young区分为两大区，Survivor+Eden
> Survivor又分为两个一样大的区

![image-20230405164300271](D:\temporary\image-20230405164300271.png)

### 对象创建过程

一般情况下，新创建的对象都会被分配到 Eden 区
一些大对象会直接分配到 Old 区，大小超过`-XX:PretenureSizeThreshold`阈值的对象直接分配到老年代
长期存活的对象进入老年代，年龄阈值通过`-XX:MaxTenuringThreshold`设置
PS：也有例外，Survivor 空间中如果相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代，无须等到年龄达到阈值

何时年龄+1？
> 对象从 Eden 区到 Survivor 区，年龄设为1
> 对象在 Survivor 区经历一次 YGC 年龄+1，年龄达到一定阈值（默认15岁）就进入老年代

![image-20230405164414727](D:\temporary\image-20230405164414727.png)

### 常见问题

==为什么有Survivor区，Eden区每次YGC，存活的对象进入老年代不行吗==
如果没有S区，老年代将被迅速填满触发 FullGC，老年代空间大GC时间也长的多，影响程序的执行和响应速度
Survivor 存在的意义就是减少被送到老年代的对象（IBM有专门的研究表明，新生代对象98%是朝生夕死）

==为什么用两个Survivor区==
解决了碎片化

==Eden:S1:S2为什么是8:1:1==
IBM的专门研究表明，新生代中的对象大概98%是朝生夕死的，为了保险默认实际使用了90%，有10%存活
10% 是其中一个 Survivor 区，算下来就是 8:1:1

## **

## 常量池

常量池位于方法区

==静态常量池&运行时常量池==

> 静态常量池属于class的一部分，由字面量和符号引用组成，在类被装载后将静态常量池加载到内存中也就是运行时常量池
> 字面量：文本，字符串以及Final修饰的内容
> 符号引用：类，接口，方法，字段等相关的描述信息

==字符串常量池==

存储字符串常量

## 对象内存布局与对齐填充

![image-20230405165148308](D:\temporary\image-20230405165148308.png)

![image-20230405165201879](D:\temporary\image-20230405165201879.png)

![image-20230405165215835](D:\temporary\image-20230405165215835.png)

对齐填充的意义在于提高 CPU 访问数据的效率，主要针对存在实例对象数据跨内存地址区域存储的情况
无对齐填充时，想要获取这个 long 类型的数据，需要读两次内存，第一次0x00-0x07，第二次0x08-0x0F
对齐填充之后，只需要读一次内存0x08-0x0F 就可以了

# 类加载机制

类加载机制就是 JVM 把 Class 文件加载到内存并对数据进行校验、转换解析和初始化，形成 JVM 可以直接使用的 java.lang.Class 类型

## 类加载过程

### 1、装载(load)

1. 类加载器通过一个类的全限定名获取定义此类的二进制字节流
   可以自定义类加载器完成加载，也可以通过 java agent 来完成字节码增强操作
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在堆内存中生成一个这个类的 java.lang.Class 对象，作为对方法区中这些数据的【访问入口】

### 2、链接(link)

#### 2.1、验证(verify)

验证是为了确保字节流包含的信息完全符合虚拟机的要求

**文件格式验证**

> 验证字节流是否符合 Class 文件格式的规范
> 主要目的是保证字节流能正确地解析并存储于方法区内；后面的验证都是基于方法区
> 举例：
> 是否以16进制 cafebaby 开头
> 版本号是否正确

**元数据验证**

> 对类的元数据信息进行语义校验，保证元数据信息完全符合语法规范
> 举例：
> 是否继承了 final 类（违反语法规范）
> 非抽象类是否实现了所有的抽象方法（否表示这个类无效）

**字节码验证**

> 进行数据流和控制流分析，确定程序语义是合法的、符合逻辑的

**符号引用验证**

> 对常量池中的各种符号引用进行匹配性的校验
> 符号引用验证的目的是确保【解析】能正常执行
> 举例：
> 常量池中描述类是否存在

如果认为验证过程完全没必要，可以添加参数`-Xverify:none`取消验证

#### 2.2、准备(prepare)

> 为类的静态变量分配内存（方法区），并将其设置为默认值
> PS：不包含 final 修饰的静态变量，因为 final 在编译时就分配了，准备阶段会显式初始化
> PS：不包含实例变量，类变量分配在方法区，实例分配到堆内存

### 3、解析(resolve)

> 把常量池中的符号引用转换为直接引用
> 符号引用：是一组符号来描述目标，可以是任何字面量
> 直接引用：是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄

### 4、初始化(initalize)

> 初始化阶段，初始化类变量和其他资源，比如赋值

**初始化步骤**
- 如果此类还没有被加载和连接，先加载并链接此类
- 如果此类的直接父类还没有被初始化，先初始化其直接父类
- 如果类中有初始化语句，依次执行这些初始化语句

**初始化时机，只有对类进行主动引用才引发初始化，主动引用有6种情况**
- 创建类的实例，即new的方式
- 访问或赋值某个类或接口的静态变量
- 调用类的静态方法
- 反射，比如Class.forName
- 初始化某个类的子类，则其父类也会被初始化
- 虚拟机启动时被标明为启动类的类（这个类有main方法）

## 类加载器

作用：读取二进制字节流，并转换为 java.lang.Class 类的一个实例

类加载器分类如下：

![image-20230314211628873](D:\temporary\image-20230314211628873.png)

类加载器的三个特点如下：

**全盘负责**

> 一个类加载器加载某个 Class，这个 Class 所依赖的和引用的其他 Class 也将由这个类加载器加载，除非显式使用另外一个类加载器来加载

**双亲委派**

> 类加载器如果没有加载过目标类，就交给父类加载器加载，父类加载器无法加载时才自己加载
> 类加载器分三层是为了实现双亲委派，双亲委派能避免类的重复加载
> 自定义类加载器，想遵守双亲委派就重写 findClass 方法，想破坏双亲委派就重写 loadClass 方法
> 破坏双亲委派的典型例子：JDBC 用了《JavaSPI破坏双亲委派》把原本需要启动类加载器加载的类交给系统类加载器加载

**缓存机制**

> 程序需要 Class 的时候都是先去缓存中找，如果缓存中没有才读取二进制字节流再存入缓存
> 因此一个类只加载一次，类变量只被初始化一次
> 因此修改了 Class 后必须重启虚拟机

## **

## 加载class文件的方式

> 1、从本地文件中加载
> 2、通过网络加载
> 3、从 jar、war 包中加载

# 垃圾回收

## 什么时候垃圾回收？

> Eden 区或 Survivor 区不够用了
> 老年代空间不够用了
> 方法区空间不够用了
> System.gc()：手动调用，引发 FullGC，不建议使用

## 如何确定对象是垃圾？

==引用计数法==
每个对象设置一个引用计数器，某个地方引用了这个对象就+1，引用失效就-1，计数器为0表示可以被回收
缺点：无法解决循环引用的问题

==可达性算法==
从一个 GCRoots 对象开始向下搜索，如果一个对象到 GCRoots 没有任何引用链相连，则说明此对象不可达可以被回收

可以作为 GCRoots 的对象有以下几种：
> 方法区类静态属性引用的对象 
> 方法区常量引用的对象
> 虚拟机栈中局部变量表中引用的对象
> 本地方法栈Native方法引用的对象

## 不可达对象一定被回收吗？

> 标签：不可达对象有一次变为可达对象的机会

不一定，不可达对象有一次变为可达对象的机会
> 1、没有重写 finalize 方法或者 finalize 方法已被虚拟机调用过的对象将等待回收
> 2、重写了 finalize 方法且 finalize 方法没有被虚拟机调用过的对象将被放在一个队列中，虚拟机触发一个线程去执行队列中对象的 finalize，若对象在 finalize 方法中重新建立与 GCRoots 的连接，对象将从队列中移除重新变得可达
> 3、GC定期将队列中的对象移除并等待回收（对象的 finalize 方法不一定能执行完）

## 垃圾回收算法

### 标记清除

> 先标记可达对象再清除不可达对象
> 是老年代算法
> 【缺点】
> 标记和清除两个过程都比较耗时，效率不高
> 会产生大量内存碎片，空间碎片太多可能导致需要分配较大对象时内存不够用而触发垃圾回收

### 复制

> 将内存划分为两块相等的区域，每次只使用其中一块，当其中一块内存用完，就将存活的对象复制到另外一块上面，然后把已经使用过的内存空间一次清除掉
> 是新生代算法
> 【缺点】空间利用率降低
> 老年代为什么不用复制算法？因为老年代存活率高，复制算法移动对象代价有点大且浪费空间

### 标记整理

> 标记可达对象，将所有可达对象都向一端移动，然后直接清理掉端边界以外的内存
> 是老年代算法
> 能解决标记清除的碎片问题，复制算法浪费内存的问题，但仍然存在效率不高的问题

### 分代收集

> 新生代：复制算法（效率高，垃圾越多越有优势）
> 老年代：标记清除或标记整理（相对来说节省空间）

## 垃圾回收器

![image-20230315044233728](D:\temporary\image-20230315044233728.png)

### Serial

> 优点：单线程，简单高效，拥有很高的单线程收集效率
> 缺点：STW
> 算法：复制算法（新生代）
> 【应用】
> Client 模式下默认的新生代收集器
> Client模式：针对 GUI 优化，启动快
> Server模式：启动慢，但启动之后的运行速度要比 Client 模式快

### Serial Old

> Serial 收集器的老年代版本，唯一的不同之处是算法不同采用标记整理算法
> 【应用】
> Client 模式下默认的老年代收集器
> Server 模式下是 CMS 回收老年代的后备方案；1.5之前与 Parallel Scanvenge 搭配使用

### ParNew

> Serial 收集器的多线程版本，唯一不同之处多线程，在多 CPU 时比 Serial 效率高
> 【应用】Server 模式下首选的新生代收集器
> -XX:+UseParNewGC 开启搭配 Serial Old

### Parallel Scavenge

> 和 ParNew 类似，不同之处在于 Parallel Scanvenge 更关注系统的吞吐量
> 【吞吐量】 = 运行用户代码的时间 /【运行用户代码的时间+垃圾收集时间】
> 比如虚拟机总共运行100分钟，垃圾收集用了1分钟，吞吐量等于99%
> 垃圾收集时间越短，吞吐量越大，用户代码可以充分利用 CPU 尽快完成程序的运算任务
> 【参数】
> -XX:+UseParallelGC 开启搭配 Serial Old，是 Server 模式下的默认值
> -XX:MaxGCPauseMillis 控制最大的STW时间
> -XX:GCRatio 设置吞吐量的大小

### Parallel Old

> Parallel Scavenge 的老年代版本，不同之处是算法采用标记整理

### CMS

上面几个垃圾回收器 GC 时都需要 STW 暂停所有用户线程
《CMS垃圾回收器》目标就是获得最短的停顿时间

### G1

《G1垃圾回收器》

### ZGC

《ZGC垃圾回收器》

### 选择合适的垃圾回收器

> 串行：Serial + SerialOld
> 并行（吞吐量优先）：PS+PO（JDK1.8默认)
> 并发（响应时间优先）： CMS + ParNew + SerialOld、G1

## **

## 四种引用类型强软弱虚

四种引用的诞生是为了更加灵活地控制对象的生命周期

>**【强引用】**
> 如果一个对象具有强引用，垃圾回收器绝不会回收它
> 当内存空间不足，虚拟机宁愿抛出 OutOfMemoryError 也不会回收具有强引用的对象
> **【软引用】**
> 如果一个对象只具有软引用，只有在内存空间不足是才会回收它
> **【弱引用】**
> 只具有弱引用的对象，在下一次GC时回收
> 举例：ThreadLocal、WeakHashMap
> **【虚引用】**
> 如果一个对象A只有虚引用，相当于没有引用，任何时候都可能被回收
> 对象A不可达后（什么时候回收不重要），PhantomReference 对象入队 ReferenceQueue，可以监听队列中的虚引用对象并做一些清理操作

## FullGC

> full gc = young gc + old gc + metaspace gc
> minor gc = young gc
> major gc = old gc

什么时候触发 FullGC？FullGC 期间全过程 STW，如何减少 Full GC？

> 1、老年代有效空间不足以满足一个内存分配时，比如新生代晋升到老年代时发现空间不够用
> 解决方案：通过调整堆的大小以及调整参数来减少 FullGC 的发生
> 2、元空间区域空间不足
> 解决方案：除非本地内存不够用，概率极小
> 3、之前每次晋升的对象的平均大小大于老年代的剩余空间
> 解决方案：同1
> 4、System.gc()
> 解决方案：不建议使用

# CMS垃圾回收器

> CMS 垃圾回收器的目标为获取最短的回收停顿时间（200ms），采用标记清除算法回收老年代

## 卡表

卡表中的元素称为卡片，每个卡片对应一个特定大小的内存块（老年代），因此每个卡片包含多个对象
卡表是为了解决老年代→新生代这种跨代引用带来的问题：YGC 时扫描整个老年代
当卡片内部发生了对象引用变化时，这个卡片被标记为脏卡，脏卡中可能包含了跨代引用，YGC 时扫描这些脏卡就行了不用扫描整个老年代
除了上面的情况，新生代对象晋升到老年代、直接在老年代分配对象也应该被卡表记录

==G1 中使用 RSet 来实现类似卡表的用途==

**写屏障**
引用先改变然后卡片标记为脏卡，才能保证后续读到脏卡中对象引用已改变，因此使用写屏障保证两个写操作的顺序

> 写屏障之前的所有写操作指令都比写屏障之后的所有写操作指令更早发生，写屏障避免两个写操作乱序
> 读屏障之前的所有读操作指令都比读屏障之后的所有读操作指令更早发生，读屏障避免两个读操作乱序

**内存伪共享问题**
如果不同线程对对象引用的更新操作恰好位于同一个卡片，卡片将被多次标记为脏卡，这就是内存伪共享，无效的操作影响性能
为了解决这个问题，JDK1.7加入一个参数`-XX:+UseCondCardMark`来控制是否进行有条件的写屏障，开启时先判断目标卡片是否是脏卡，如果是就不再重复进行标记了

关联话题：《标签：缓存行与伪共享》

## 标记清除过程

![image-20230314232052876](D:\temporary\image-20230314232052876.png)

### 1、初始标记

标记 GCRoots 直接可达的老年代对象，不用扫描引用链，STW但很快

### 2、并发标记

采用《三色标记法》

### 3、并发预清理

扫描脏卡，标记可达对象并将脏页改为正常卡页
同时可能产生新的脏卡，但数量将越来越少，从而减少后续重新标记阶段的时间

### 4、可中断的并发预清理

也是处理脏卡，区别在于并发预处理只执行一次，而本阶段会一直循环执行，直到触发中断条件

> 为了减少重新标记阶段扫描新生代对象的时间，CMS 在这个阶段提供了三个参数
> CMSScheduleRemarkEdenSizeThreshold 默认2M
> CMSScheduleRemarkEdenPenetration 默认50%
> CMSMaxAbortablePrecleanTime 默认5秒
> Eden 区内存占用超过 2M 时开启可中断的并发预清理阶段，内存占用达到 50% 时将触发一次 YGC 并中断并发预清理
> 即使不触发 YGC，5秒之后也将中断并发预清理

### 5、重新标记

重新标记阶段STW
重新标记阶段需要扫描整个新生代，因为并发期间新生代对象可能持有老年代对象的引用
重新标记阶段遍历 GCRoots 重新标记（绝大多数对象都是黑色，因此扫描广度不变，深度大大降低，扫描很快）
PS：此阶段不用扫描脏卡，因为遍历新生代和老年代能找到所有可达对象，而前面并发阶段扫描脏卡是为了标记为黑色减轻这个阶段深度扫描的压力

> CMSScavengeBeforeRemark 参数开启之后可以在重新标记之前进行一次 YGC

### 6、并发清理

清理掉没有标记的对象

## 优缺点

【优点】
并发收集、低停顿

【缺点】
产生大量空间碎片，增加大对象无法分配触发 FullGC 的可能性《G1解决了这个问题》
并发阶段会降低吞吐量

## FullGC

《FullGC》

**CMS可以通过调低阈值来降低因老年代空间不足触发 FullGC 的可能性**

```shell
#+Use表示开启使用设定的阈值，-Use表示仅第一次使用设定阈值后续自动调整
-XX:+UseCMSInitiatingOccupancyOnly
#老年代内存使用率达到阈值触发GC
-XX:CMSInitiatingOccupancyFraction=70
```

## 三色标记算法

> 白色：表示对象尚未被垃圾收集器访问过；可达性分析开始时所有对象都是白色，结束时白色对象代表不可达
> 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过
> 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过，是安全存活的；如果有其他对象的引用指向黑色对象，无须重新扫描

**【标记过程】**

1. 可达性分析开始时，所有对象都是白色
2. 将 GCRoots 直接引用到的对象标记为灰色
3. 遍历所有灰色对象
   1. 将本对象引用到的其他对象全部标记为灰色
   2. 将本对象标记为黑色
4. 重复步骤3直到没有灰色对象时结束
5. 可达性分析结束后，白色对象是不可达对象，可以进行回收

**【多标】**
在并发标记阶段，标记过可达对象之后，如果这个对象重新变为不可达，就成为浮动垃圾，将在下一轮 GC 回收

**【漏标】**
漏标需要同时满足两个条件

> 灰色对象删除了指向白色对象的引用
> 黑色对象重新引用了该白色对象

漏标将导致可达对象被当成垃圾回收，有两种解决方案，CMS使用增量更新，G1使用原始快照
> 增量更新：当黑色对象增加这个引用时后，记录这个引用，等并发标记结束后，再以引用中的黑色对象为根重新标记一次；用卡表记录卡片变为脏卡，利用写屏障先增加引用再记录新增的引用
> 原始快照（STAB）：当灰色对象删除这个引用前，记录这个引用，等并发标记结束后，再以引用中的灰色对象为根重新标记一次（白色对象可能变为浮动垃圾）；利用写屏障，先记录引用再删除引用

## 常用参数

| 参数                              | 用途                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| -XX:+UseConcMarkSweepGC           | 开启CMS；Java8之前默认Parallel，9之后默认G1                  |
| -XX:+UseParNewGC                  | 开启CMS后默认开启，年轻代使用多线程垃圾回收                  |
| -XX:+CMSParallelRemarkEnabled     | 采用并行标记方式降低停顿，默认开启                           |
| -XX:+CMSConcurrentMTEnabled       | 并发的CMS阶段将以多线程执行，默认开启                        |
| -XX:ConcGCThreads                 | GC和用户线程并发时使用的GC线程数，一般较小                   |
| -XX:ParallelGCThreads             | STW时使用的GC线程数，一般用满CPU                             |
| XX:CMSInitiatingOccupancyFraction | 老年代堆空间超过此值便开始GC，默认68%，需配合UseCMSInitiatingOccupancyOnly使用 |
| XX:+UseCMSInitiatingOccupancyOnly | 开启后CMSInitiatingOccupancyFraction生效，默认关闭           |
| -XX:+CMSClassUnloadingEnabled     | CMS对永久代进行垃圾回收，默认关闭                            |
| -XX:+CMSScavengeBeforeRemark      | 重新标记之前做一次YGC，默认关闭                              |
| -XX:+ExplicitGCInvokesConcurrent  | 启用后，调用 System.gc() 将进行并行 FullGC 提高效率          |
| -XX:+UseCompressedOops            | 压缩对象提高内存利用率，默认开启                             |

## 推荐参数

8C16G服务器【再大的服务器可以用G1 】

```shell
-Xmx12g -Xms12g
-XX:ParallelGCThreads=8
-XX:ConcGCThreads=2
-XX:+UseConcMarkSweepGC
-XX:+CMSClassUnloadingEnabled
-XX:+CMSIncrementalMode
-XX:+CMSScavengeBeforeRemark
-XX:+UseCMSInitiatingOccupancyOnly
-XX:CMSInitiatingOccupancyFraction=70
-XX:CMSFullGCsBeforeCompaction=5
-XX:MaxGCPauseMillis=100  #按业务情况来定
-XX:+ExplicitGCInvokesConcurrent
-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses
-XX:+PrintGCTimeStamps
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
```

4C8G

```shell
-Xmx6g -Xms6g
-XX:ParallelGCThreads=4
-XX:ConcGCThreads=1
-XX:+UseConcMarkSweepGC
-XX:+CMSClassUnloadingEnabled
-XX:+CMSIncrementalMode
-XX:+CMSScavengeBeforeRemark
-XX:+UseCMSInitiatingOccupancyOnly
-XX:CMSInitiatingOccupancyFraction=70
-XX:CMSFullGCsBeforeCompaction=5
-XX:MaxGCPauseMillis=100  #按业务情况来定
-XX:+ExplicitGCInvokesConcurrent
-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses
-XX:+PrintGCTimeStamps
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
```

2C 不推荐使用，线程上下文切换开销比较大

## **

## 为什么不用卡表解决新→老这种跨代引用？

1、重新标记之前往往有一次 YGC，之后存活的对象就不多了，扫描很快
2、新生代对象不稳定，引用可能经过很多次切换，就得写很多次卡表，这样的开销是没有必要的

## 为什么重新标记前一次YGC能减轻压力？

因为新生代朝生夕死垃圾很多，一次 YGC 就能回收大量的 GCRoots 对象【比如方法中局部变量引用的对象】，减轻扫描压力

## 不可达对象能变可达吗？

不可能的，一个对象失去所有引用之后就无法再被引用了
PS：仅有的可能性是在 finallize 方法中，但 Java 不建议使用这个方法，参考《不可达对象有一次变为可达对象的机会》
> finallize 方法执行时间无法保证
> finallize 方法不一定能执行完
> finallize 方法中有耗时操作将影响GC效率

## OGC并发阶段与YGC用同一个卡表吗？

不是
YGC 为了避免跨代引用造成的扫描老年代，用的卡表在每次 YGC 之后将重置
因此 OldGC 使用一个类似的卡表叫 mod-union card，每次 YGC 将卡表中的脏卡迁移到 mod-union card

## 初始标记为什么STW？

并发的话可能增加新的GC Roots，有可能永远都扫不完

## 重新标记阶段为什么遍历GCRoots？

写屏障并不是对所有造成引用变化的字节码生效
例如对字节码 astore_X（把栈顶的值存到本地变量表）无效，则增量更新可能不被卡表记录
因此重新标记阶段扫描卡表还是可能漏标，因此选择遍历GCRoots不再扫描卡表

> 为什么不为 astore_X 添加写屏障？
> 可能是栈和年轻代属于数据快速变化的区域，对于这些区域使用写屏障的收益比较差

# G1垃圾回收器

## 先了解一下

JDK7出现，8推荐使用，9成为默认的

## 特点（相对于CMS）

1、内存空间重新定义，内存使用更灵活，堆空间由大小相等的分区组成（Region），每个分区大小1M-32M
2、逻辑分代（年轻代和老年代），物理不分代
3、非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收
4、转移对象达到了内存整理的效果，某种程度上解决了内存碎片
5、G1在新生代和老年代都有使用，不像之前的回收器只应用于某一个区域
![image-20230314222517240](D:\temporary\image-20230314222517240.png)

## TLAB

G1 中为了减少锁冲突提高效率，JVM 为每个线程在 Eden 区开辟了一个缓存区域称为 TLAB
如果启动了本地线程分配缓冲，对象优先在 TLAB 上分配，但 TLAB 空间通常比较小，比较大的对象还是在共享区域分配的

## CSet

> 全称是 Collection Set

**CSet 存储了每次垃圾回收的一系列目标分区（Region）**
YGC 时 CSet 只容纳新生代分区
MixedGC 时 CSet 除了容纳新生代分区，还容纳从老年代候选回收分区中筛选出来的回收收益最高的分区

## RSet

> 全称是 Remember Set

RSet 是卡表的升级，也是为了解决跨代引用避免跨代扫描
RSet 存储 Region 中对象的引用关系，每个 Region 都有一个 RSet

RSet 的三级数据结构分别是稀疏表、细粒度位图、粗粒度位图

**稀疏表**
是一种哈希表，Key 是 Region 的索引，Value 是一个数组，里面存储是卡页的索引号
![image-20230314222619214](D:\temporary\image-20230314222619214.png)

**细粒度位图**
当稀疏表某个 Region 的卡页数量超过阈值，就在当前 Region 中创建细粒度位图，每一位对应一个卡页
![image-20230314222651252](D:\temporary\image-20230314222651252.png)

**粗粒度位图**
当细粒度位图 size 超过阈值，所有 Region 形成一个位图，每一位对应一个 Region
![image-20230314222714341](D:\temporary\image-20230314222714341.png)

## 垃圾回收模式

### YGC

**回收过程**

> 全过程STW
> 对于老年代对象的引用指向新生代对象，JVM 将其所在卡页入队 Dirty Card Queue
> 在新生代回收的时候，JVM 将 Dirty Card Queue 中所有卡页存入 RSet
> 为什么不直接存入 RSet？为了性能，RSet 的处理线程同步开销大，使用队列性能好很多

1、将所有新生代 Region 放入 CSet
2、对 CSet 中的对象，从 GC Roots 开始进行可达性分析，标记存活对象
3、取出 Dirty Card Queue 中所有卡页存入 RSet，利用 RSet 标记被老年代对象引用的新生代对象
4、多线程并行移动标记的对象，Eden 区存活对象移动到 Survivor 区，Survivor 区存活对象年龄未达阈值的年龄加1，达到阈值的移动到 Old 区；如果 Survivor 空间不够 Eden 区的存活对象直接晋升到 Old 区

**触发条件**
Eden 区的大小范围`[-XX:G1NewSizePercent, -XX:G1MaxNewSizePercent]=[整堆5%, 整堆60%]`
Eden 区不够用时，G1 计算现在回收 Eden 区的时间；如果时间远远小于参数`-XX:MaxGCPauseMills`设定的值（默认200ms），就增加年轻代的 Region 继续给新对象存放；如果时间接近参数`-XX:MaxGCPauseMills`设定的值，就触发 YGC

### MixedGC

**全局并发标记**
> 注意是全局，包含新生代老年代

1、初始标记：标记 GCRoots 直接可达的对象，STW但很快
2、并发标记：使用初始标记的对象扫描引用链，标记可达对象
3、重新标记：修正上一次的标记结果，处理 STAB，STW很快
4、筛选分区：CSet 纳入新生代所有分区，纳入STW时间不超过上限且优先级最高的一部分老年代分区，STW但很快
5、清理：多线程并行移动被标记的对象（同YGC），STW时间可能较长
PS：3、4、5都是STW因此最后清理没有漏标的情况

**触发条件**
`-XX:InitiatingHeapOccupancyPercent`当老年代大小占整个堆大小百分比达到阈值时触发

### FullGC

FullGC 期间由 Serial Old 回收老年代

> JDK10之前都是单线程，JDK10及以后多线程并行

《FullGC》

## 常用参数

`-XX:+UseG1GC`开启G1
`-XX:G1HeapReginSize`设置每个Region的大小，是2的N次方，1MB-32MB
`-XX:MaxGCPauseMillis`最大停顿时间
`-XX:ParallelGCThread`并行GC工作的线程数
`-XX:ConcGCThreads`并发标记的线程数
`-XX:InitiatingHeapOcccupancyPercent`默认45%，代表GC堆占用达到多少的时候开始垃圾收集
`-XX:MaxTenuringThreshold`默认是15，一个对象经历多少次GC周期之后晋升到老年代
`-XX:NewRatio`新生代和老年代大小的比例，默认是2
`-XX:SurvivorRatio`Eden和Survivor区空间大小的比例，默认是8
`-XX:G1ReservePercent`预留多少内存，防止晋升失败的情况，默认值是10

## 移动对象阶段为什么STW？

未能解决转移过程中准确定位对象地址的问题
这个问题 ZGC 解决了

# ZGC

## 先了解一下这些

 - ZGC 依然使用类似 G1 的内存分区（Region）
 - ZGC 无论是逻辑上还是物理上都不分代，无需考虑跨代引用的问题
 - 标记对象指针：标记阶段标记为 M0 or M1（前后两次做区分），对象转移完成后标记为 Remapped
 - 标记整理算法
 - 可以达到10ms以内的停顿，堆内存变大后停顿时间还是在10ms以内

## 染色指针、多重映射、读屏障

之前的垃圾回收器都是把标记信息存在对象头的 Mark Word，标记的时候需要寻址找到对象修改其标记
64位 Linux 系统支持46位内存物理地址空间寻址，ZGC的==染色指针==将46位指针宽度的高4位中的3位用来存储标志信息：Remapped、Mark0、Mark1（如下图）

![image-20230314214946728](D:\temporary\image-20230314214946728.png)

![image-20230314214959663](D:\temporary\image-20230314214959663.png)

==内存的多重映射==是使用染色指针的前置条件；因高4位用来标志信息是经常变化的，而对象的物理地址是稳定不变的，因此只能使用剩余的42位来存储对象地址（ZGC能够管理的内存是4T），因此染色指针必然是一个虚拟地址，映射到真实的对象指针，染色指针有三个标记位因此一个对象需要三个虚拟地址
==染色指针的优势是==：在标记阶段，不必寻址到对象修改对象头的标记位，直接修改指针的标记位速度更快

下面是 ZGC 的垃圾回收过程，继承于 CMS 和 G1

![image-20230314215052173](D:\temporary\image-20230314215052173.png)

> 1、初始标记：标记 GCRoot 直接引用的对象，STW但很快
> 2、并发标记：三色标记算法
> 3、重新标记：重新扫描漏标对象，包括三色标记漏标的（STAB解决同G1）、新创建的对象，STW但很快
> 4、并发转移准备：筛选回收价值最大的分区
> 5、初始转移：xxx不重要
> 6、并发转移：与 G1 不同的是没有 STW，怎么做到对象的重定位问题呢
> PS：当标记阶段结束后，ZGC会把所有活跃对象的地址存到对象活跃信息表
> PS：只需考虑三色标记过程中的漏标，标记完之后就不必再担心了，因为不可达对象永远不可能变为可达，而可达对象即使变为浮动垃圾也没什么大影响

G1中转移阶段是STW的，相当于锁住不让用户线程访问；如果是并发的，用户线程可能出现的问题是使用旧的对象指针找不到新对象
==ZGC 解决了对象重定位==；ZGC 维护了一个转移表，对象转移成功之后将新旧对象的关系写入转移表；用户线程访问对象时被==读屏障==拦截，如果指针被染色且转移表中有这个指针，就将访问新对象，同时修改指针并删除转移表记录（各个操作的先后顺序已经考虑到）
==读屏障==：和内存屏障不是一个概念，类似于AOP，是 JVM 向应用代码插入一小段代码的技术，只有当应用线程读取对象引用时才执行这段代码

## 最佳调优参数

```shell
#堆的最大内存和最小内存，这里都设置为16G，程序的堆内存将保持16G不变
-Xms16G -Xmx16G
#设置CodeCache的大小，即时编译的代码都放在CodeCache中，一般服务64m或128m就已经足够
-XX:ReservedCodeCacheSize=256m -XX:InitialCodeCacheSize=256m
#启用ZGC
-XX:+UnlockExperimentalVMOptions -XX:+UseZGC
#并发回收垃圾的线程数；默认是总核数的12.5%，8核CPU默认是1，调大后GC变快，但会占用CPU资源，吞吐会受到影响
-XX:ConcGCThreads=2
#STW阶段使用线程数，默认是总核数的60%
-XX:ParallelGCThreads=6
#ZGC发生的最小时间间隔，单位秒
-XX:ZCollectionInterval=120
#ZGC触发自适应算法的修正系数，默认2，数值越大，越早的触发ZGC
-XX:ZAllocationSpikeTolerance=5
#是否启用主动回收，默认开启，这里的配置表示关闭
-XX:-ZProactive
#设置GC日志中的内容、格式、位置以及每个日志的大小
-Xlog:safepoint,classhisto*=trace,age*,gc*=info:file=/opt/logs/logs/gc-%t.log:time,tid,tags:filecount=5,filesize=50m
```

## 垃圾回收触发时机

- 阻塞内存分配时触发：垃圾将堆内存占满来不及回收将导致部分线程阻塞；日志中关键字是`Allocation Stall`
- 自适应算法：是最主要的触发方式；`ZAllocationSpikeTolerance`是算法修正系数默认为2，数值越大越早触发GC；日志中关键字是`Allocation Rate`（流量突增时自适应算法触发的时机可能会过晚）
- 基于固定时间间隔：通过`ZCollectionInterval`控制，适合应对流量突增场景
- 主动触发规则：类似于固定间隔规则，但时间间隔不固定，是ZGC自行算出来的时机，通过`ZProactive`关闭此功能，以免GC频率过高影响服务可用性；日志中关键字是`Proactive`
- 外部触发：代码中显式调用`System.gc()`触发；日志中关键字是`System.gc()`
- 元数据分配触发：元数据区不足时导致，一般不需要关注；日志中关键字是`Metadata GC Threshold`

# JVM的优化

## 运行时优化

==方法内联==
方法调用次数超过阈值后，JVM将方法调用替换为嵌入方法中的代码，消除了调用成本
这部分开销来自于栈帧的生成和弹出，如果方法嵌套过多额外开销就越多
一个方法满足以下条件就可能被内联：

> 热点代码，热点代码的执行次数阈值可以通过参数调整
> 方法体不能太大
> 用 private、static、final 修饰，这样 JVM 可以直接内联，如果是 public 还得判断是内联父类还是子类

==逃逸分析==

逃逸分析并不是直接的优化手段，而是一个代码分析，为其他优化手段（栈上分配、同步消除、标量替换）提供依据
一个对象的指针被多个方法或线程引用时，那么我们就称这个对象的指针逃逸

==栈上分配==
将堆分配转化为栈分配；如果指向对象的指针永远不会逃逸，这个对象就可以分配在栈上；可以降低GC的频率

==同步消除==
如果发现某个对象只能从一个线程访问，那么在这个对象上的操作可以不需要同步

==标量替换==
1、标量是指不可分割的量，如基本数据类型
2、如果把一个对象拆散，将其成员变量恢复到基本类型来访问就叫做标量替换
3、如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是在栈上创建若干个成员变量
4、通过`-XX:+EliminateAllocations`可以开启标量替换，`-XX:+PrintEliminateAllocations`查看标量替换情况

# 调优

## 参数

标准参数：

```shell
java -version
java -help
```
-X参数：

> 非标准参数，也就是在JDK各个版本中可能会变动

```
-Xint     解释执行
-Xcomp    第一次使用就编译成本地代码
-Xmixed   混合模式，JVM自己来决定
```
-XX参数：

> 非标准参数，主要用于JVM调优和debug
> 分为布尔类型和KV类型

```shell
#查看参数
java -XX:+PrintFlagsFinal -version > flags.txt

# =表示默认值，:=表示用户或JVM修改过的值
```
常用参数：
![image-20230406172142837](D:\temporary\image-20230406172142837.png)

## 常用命令

### jps

> 查看 java 进程

```shell
jps
jps -l
```
### jinfo

> 查看和调整JVM参数

```shell
jinfo PID

#查看赋过值的参数
jinfo -flags PID
#查看某个参数
jinfo -flag MaxNewSize PID

#修改参数值
jinfo -flag <name>=<value> PID
```
### jstat

```shell
#查看某个java进程的类装载信息，每1000毫秒输出一次，共输出10次
jstat -class PID 1000 10

#查看垃圾收集信息
jstat -gc PID 1000 10
```
### jstack

```shell
#查看线程堆栈信息
jstack PID
```
### jmap

```shell
#打印堆内存相关信息
jmap -heap PID

#dump出堆内存相关信息
jmap -dump:format=b,file=heap.hprof PID

#内存溢出时自动导出
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof
```
## 常用工具

性能监控工具：==JConsole==查看Java应用程序的运行概况， 监控内存（堆、非堆）、 元空间使用情况及类的加载情况等
线程：界面上部显示实时线程数目；下部还能查看到详细的每个进程及相应状态、等待、堆栈追踪等信息；线程死锁
类：已装载的类、已经卸载的类
虚拟机摘要：包括操作系统，垃圾回收器、内存、线程等
MBean：可在此页进行参数的配置

# **

# Java内存模型

Java 内存模型是一个并发模型，规定所有的变量都是存在主内存中，每个线程都有自己的工作内存

引申到计算机操作系统层面《Java内存模型》

# 堆内存中都是线程共享区域吗

《TLAB》

# 访问对象有几种方式

1、通过句柄池访问
2、直接访问
直接访问节省了一次指针定位的开销

# JVM的主要组成部分及其作用

JVM 包含两个子系统（类加载器、执行引擎）和两个组件（运行时数据区、本地接口）

> 类加载器：根据全限定名类名装载 class 文件到运行时数据区的方法区
> 执行引擎：执行指令
> 运行时数据区：JVM的内存
> 本地接口：与本地库交互，是与其他编程语言交互的接口

类加载器把字节码加载到方法区内，执行引擎将字节码翻译成底层系统指令并交给 CPU 去执行，而这个过程中需要调用其他编程语言的本地库接口来实现整个程序的功能

# 堆栈的区别

物理地址：
堆的物理地址分配对象是不连续的，因此性能慢些，在GC的时候也要考虑到不连续的分配
栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的，所以性能快

内存分别：
堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定
栈是连续的，所以分配的内存大小在编译期就确认，大小是固定的

存放的内容：
堆存放的是对象的实例和数组（关注数据的存储）
栈存放局部变量、操作数栈、返回结果（关注方法的执行）

# 内存溢出和内存泄漏

内存溢出：是指应用程序在申请内存时，没有足够的内存空间供其使用，出现OOM
内存泄漏：是指应用程序在申请内存之后，无法释放已经申请的内存空间，内存泄漏最终将导致内存溢出

一个内存泄漏的例子：
`ThreadLocal`是一个工具类，真实的数据存储在 Thread 的 ThreadLocalMap 中
map 中 value 是局部变量，key 是一个弱引用的 ThreadLocal 实例，一旦垃圾回收 key 就被清理掉，value 将访问不到
因此用完之后应该及时 remove 掉

# 调优案例

## 案例1-堆空间的OOM

业务反馈我们的网站经常502，我下载好 dump 文件后使用 MAT 查看大对象的堆栈信息，然后定位到代码的位置，是 Excel 导入的问题

经测试，几兆的 Excel 文件导入就占用 1G+ 内存（读取使用WorkBook的方式）

去查 POI 文档，Excel 分为两个模式

- 用户模式：也就是 poi 的 usermodel 有关包，它对用户友好，有统一的接口在 ss 包下，但它是把整个文件读取到内存中的，对于大量数据很容易内存溢出，所以只能用来处理相对较小量的数据
- 事件模式：在 poi 的 eventusermodel 包下，相对来说实现复杂，但它处理速度快，占用内存少，可以用来处理海量数据

参考了官方 example 使用事件模式读取 Excel 解决了这个问题

## 案例2-元空间OOM导致频繁FullGC

以前有个项目，（通过监控大屏）线上每隔一段时间元空间内存占用就直线上升导致频繁 FullGC

《元空间》，初步怀疑是加载了过多的类导致的
于是就通过`-verbose:class`查看类加载信息，看到了有大量的`ASMAccessorImpl`类被加载，搜索这个关键字定位到代码找到了原因
原因：项目中使用了 mvel 表达式解析引擎，每次请求都会生成一个类对象，从而导致方法区不断膨胀，经过缓存改造后解决
